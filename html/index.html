<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Axofuego Fire Control</title>
    <!-- Stylesheet -->
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
      <div id="cputemp">Waiting for CPU Temp....</div>
      
      <!-- GPIO Status Section -->
      <div class="gpio-status">
        <h3>GPIO Status</h3>
        <div class="gpio-grid">
          <div class="gpio-pin" id="gpio-pin-17">
            <div class="pin-indicator" id="indicator-17"></div>
            <span>Pin 17 (P1)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-22">
            <div class="pin-indicator" id="indicator-22"></div>
            <span>Pin 22 (P2)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-27">
            <div class="pin-indicator" id="indicator-27"></div>
            <span>Pin 27 (P3)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-4">
            <div class="pin-indicator" id="indicator-4"></div>
            <span>Pin 4 (P4)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-23">
            <div class="pin-indicator" id="indicator-23"></div>
            <span>Pin 23 (P5)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-24">
            <div class="pin-indicator" id="indicator-24"></div>
            <span>Pin 24 (P6)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-25">
            <div class="pin-indicator" id="indicator-25"></div>
            <span>Pin 25 (P7)</span>
          </div>
          <div class="gpio-pin" id="gpio-pin-9">
            <div class="pin-indicator" id="indicator-9"></div>
            <span>Pin 9 (P8)</span>
          </div>
        </div>
      </div>
      
    <div class="container">
      <div id="tail">TAIL FIRE</div>
      <div id="out-left">FIRE</div>
      <div id="mid-left">FIRE</div>
      <div id="in-left">FIRE</div>
      <div id="in-right">FIRE</div>
      <div id="mid-right">FIRE</div>
      <div id="out-right">FIRE</div>
      <div id="sequence1">Seq1</div>
      <div id="sequence2">Seq2</div>
      <div id="sequence3">Seq3</div>
      <div id="all">ALL</div>
      <p id="status">Ready For fire</p>
    </div>
    <!-- Script -->
    <script>
      // Get WebSocket port from environment or default
      const WS_PORT = 8767; // Development port
      const WS_HOST = window.location.hostname || 'localhost';
      const WS_PROTOCOL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      
      //Create Initial References
      let tail = document.getElementById("tail");
      let outleft = document.getElementById("out-left");
      let midleft = document.getElementById("mid-left");
      let inleft = document.getElementById("in-left");
      let inright = document.getElementById("in-right");
      let midright = document.getElementById("mid-right");
      let outright= document.getElementById("out-right");
      let sequence1 = document.getElementById("sequence1");
      let sequence2 = document.getElementById("sequence2");
      let sequence3 = document.getElementById("sequence3");
      let all = document.getElementById("all");
      let status = document.getElementById("status");
      let cputemp = document.getElementById("cputemp");
      let isMouseHold = true;
      let timeoutref;
      let deviceType = "";

      //Events Object
      let events = {
        mouse: {
          down: "mousedown",
          up: "mouseup",
        },
        touch: {
          down: "touchstart",
          up: "touchend",
        },
      };
      
      //Detect if the device is a touch device
      const isTouchDevice = () => {
        try {
          document.createEvent("TouchEvent");
          deviceType = "touch";
          return true;
        } catch (e) {
          deviceType = "mouse";
          return false;
        }
      };
      isTouchDevice();
      
      // Persistent WebSocket connections
      let tempSocket = new WebSocket(
          `${WS_PROTOCOL}//${WS_HOST}:${WS_PORT}/fire/cputemp`
      );
      tempSocket.onmessage = (event) => {
        cputemp.textContent = event.data;
      };

      let controlSocket = new WebSocket(
          `${WS_PROTOCOL}//${WS_HOST}:${WS_PORT}/fire/control`
      );
      
      controlSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('Control response:', data);
        } catch (e) {
          console.error('Failed to parse control message:', e);
        }
      };
      
      controlSocket.onclose = (event) => {
        console.log('Control connection closed');
      };
      
      controlSocket.onerror = (error) => {
        console.error('Control WebSocket error:', error);
      };

      // Status WebSocket for real-time GPIO visualization
      let statusSocket = new WebSocket(
          `${WS_PROTOCOL}//${WS_HOST}:${WS_PORT}/fire/status`
      );
      
      statusSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'status_update') {
            // Only log when there's actual activity
            const anyActive = Object.values(data.poofers || {}).some(p => p.active);
            if (anyActive) {
              console.log('ðŸ”¥ GPIO Activity:', data.poofers);
            }
            updateGPIOVisualization(data.poofers);
            updatePatternStatus(data.pattern_status);
          }
        } catch (e) {
          console.error('Failed to parse status message:', e);
        }
      };
      
      statusSocket.onclose = (event) => {
        console.log('Status connection closed');
      };
      
      statusSocket.onerror = (error) => {
        console.error('Status WebSocket error:', error);
      };

      // GPIO pin mapping (pin -> poofer ID)
      const pinToPoofer = {
        17: 1, 22: 2, 27: 3, 4: 4, 23: 5, 24: 6, 25: 7, 9: 8
      };

      // Update GPIO visualization based on poofer states
      function updateGPIOVisualization(poofers) {
        if (!poofers) return;
        
        for (const [pin, pooferId] of Object.entries(pinToPoofer)) {
          const indicator = document.getElementById(`indicator-${pin}`);
          if (indicator && poofers[pooferId]) {
            const isActive = poofers[pooferId].active;
            
            // Force a visual change for debugging
            if (isActive) {
              indicator.style.backgroundColor = '#ff4444';
              indicator.style.borderColor = '#ff6666';
              indicator.style.boxShadow = '0 0 10px #ff4444';
            } else {
              indicator.style.backgroundColor = '#333';
              indicator.style.borderColor = '#666';
              indicator.style.boxShadow = 'none';
            }
          }
        }
      }

      // Update pattern status display
      function updatePatternStatus(patternStatus) {
        // Could add pattern status indicators here in the future
        console.log('Pattern status:', patternStatus);
      }

      // Helper function to send fire control command
      function sendFireCommand(action, target) {
        if (controlSocket.readyState === WebSocket.OPEN) {
          controlSocket.send(JSON.stringify({ action, target }));
        }
      }

      // Individual fire controls
      tail.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'tail');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });

      outleft.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'left-outside');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });

      midleft.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'left-middle');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });
      
      inleft.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'left-inside');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });

      inright.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'right-inside');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });

      midright.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'right-middle');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });

      outright.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'right-outside');
        e.preventDefault();
        status.innerText = "Shooting Fire!!";
      });

      // Sequence controls
      sequence1.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'sequence1');
        e.preventDefault();
        status.innerText = "Running Sequence 1";
      });

      sequence2.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'sequence2');
        e.preventDefault();
        status.innerText = "Running Sequence 2";
      });

      sequence3.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'sequence3');
        e.preventDefault();
        status.innerText = "Running Sequence 3";
      });

      all.addEventListener(events[deviceType].down, (e) => {
        sendFireCommand('fire', 'all');
        e.preventDefault();
        status.innerText = "ALL POOFERS ACTIVE!!";
      });

      // Release handlers
      tail.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'tail');
        status.innerText = "Ready for fire";
      });

      outleft.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'left-outside');
        status.innerText = "Ready for fire";
      });

      midleft.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'left-middle');
        status.innerText = "Ready for fire";
      });

      inleft.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'left-inside');
        status.innerText = "Ready for fire";
      });

      inright.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'right-inside');
        status.innerText = "Ready for fire";
      });

      midright.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'right-middle');
        status.innerText = "Ready for fire";
      });

      outright.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'right-outside');
        status.innerText = "Ready for fire";
      });

      sequence1.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'sequence1');
        status.innerText = "Ready for fire";
      });

      sequence2.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'sequence2');
        status.innerText = "Ready for fire";
      });

      sequence3.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'sequence3');
        status.innerText = "Ready for fire";
      });

      all.addEventListener(events[deviceType].up, () => {
        sendFireCommand('stop', 'all');
        status.innerText = "Ready for fire";
      });
    </script>
  </body>
</html>